<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Course Overview | Skanda Vaidyanath</title>
    <link>https://skandavaidyanath.github.io/courses/rl-course/</link>
      <atom:link href="https://skandavaidyanath.github.io/courses/rl-course/index.xml" rel="self" type="application/rss+xml" />
    <description>Course Overview</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sun, 09 Sep 2018 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://skandavaidyanath.github.io/img/icon-192.png</url>
      <title>Course Overview</title>
      <link>https://skandavaidyanath.github.io/courses/rl-course/</link>
    </image>
    
    <item>
      <title>Introduction: Why RL?</title>
      <link>https://skandavaidyanath.github.io/courses/rl-course/post1/</link>
      <pubDate>Sun, 05 May 2019 00:00:00 +0100</pubDate>
      <guid>https://skandavaidyanath.github.io/courses/rl-course/post1/</guid>
      <description>

&lt;p&gt;Hi and welcome to the first post of this RL course. In this post, my aim will be to introduce the idea of RL to you and talk about the problems it solves and why its important.&lt;/p&gt;

&lt;p&gt;Reinforcement learning is like that little-known cousin of supervised learning and unsupervised learning. Or at least it was for the longest time. In recent times though, its been gaining a lot of attention, mainly due to &lt;a href=&#34;https://deepmind.com/blog/article/alphazero-shedding-new-light-grand-games-chess-shogi-and-go&#34; target=&#34;_blank&#34;&gt;DeepMind&amp;rsquo;s AlphaZero&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;But having said that, people still don&amp;rsquo;t quite know what RL is yet and don&amp;rsquo;t know how and when to use it. So as a part of this introductory blog, I will try to answer three questions that people often ask me about RL&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;What is Reinforcement Learning?&lt;/li&gt;
&lt;li&gt;How is it different from Supervised learning or Unsupervised learning?&lt;/li&gt;
&lt;li&gt;What problems can it solve?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;And lets begin!&lt;/p&gt;

&lt;h3 id=&#34;what-is-reinforcement-learning&#34;&gt;What is Reinforcement Learning?&lt;/h3&gt;

&lt;p&gt;Reinforcement learning is a sub-part of Machine Learning (ML). The most general way to divide ML into three parts would be as Supervised learning (SL), Unsupervised learning (USL) and Reinforcement Learning. But most people only talk about SL and USL when they talk about ML.
So my first job is to explain why the third paradigm is important and how it is different from the first two.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Reinforcement learning is an area of machine learning concerned with how software agents ought to take actions in an environment in order to maximize some notion of cumulative reward.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The above definition is taken from Wikipedia.
The definition speaks about &amp;ldquo;agents&amp;rdquo; taking &amp;ldquo;actions&amp;rdquo; in &amp;ldquo;environments&amp;rdquo; to maximize &amp;ldquo;rewards&amp;rdquo;. But what does all this mean? Lets break it down, but before that, here is a simpler definition.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Reinforcement learning is simply learning by trial and error.&lt;/p&gt;
&lt;/blockquote&gt;




  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://skandavaidyanath.github.io/img/post1_rl.png&#34; data-caption=&#34;The RL Setup. Source: Google Images&#34;&gt;
&lt;img src=&#34;https://skandavaidyanath.github.io/img/post1_rl.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    The RL Setup. Source: Google Images
  &lt;/figcaption&gt;


&lt;/figure&gt;


&lt;p&gt;Think about how you started learning to ride a bike. You probably tried a bunch of different things and continued doing more of what worked (&amp;ldquo;worked&amp;rdquo; in this context probably means &amp;ldquo;did not fall and moved in the intended direction&amp;rdquo;) and less of what didn&amp;rsquo;t. Nobody gave you clear instructions on what to do at each step, you just tried things and they worked. In fact, humans gain several skills in the same fashion. Imagine you&amp;rsquo;re playing a brand new video game without reading the instructions or picking up a new sport. Humans learn several tasks by trial and error and that&amp;rsquo;s exactly what we&amp;rsquo;re trying to emulate with RL. Trying to get as close as possible to the way humans learn.&lt;/p&gt;

&lt;p&gt;With that intuition, lets take a jab at the Wikipedia definition again. The &amp;ldquo;agent&amp;rdquo; in our biker example is the person trying to learn to ride a bike. The &amp;ldquo;environment&amp;rdquo; is everything that may affect the person riding the bike &amp;ndash; so this could be the road, the traffic, the weather, etc. As for &amp;ldquo;actions&amp;rdquo;, these are the different decisions the agent can make &amp;ndash; for example, they could be &amp;ldquo;turn left&amp;rdquo;, &amp;ldquo;turn right&amp;rdquo;, etc. The agent must decide based on the state of the environment, what the right action to play is at a given point. And finally &amp;ldquo;rewards&amp;rdquo; is some sort of feedback we get for the series of actions we just took. So we would get a positive reward if we reached our destination and negative if we fell down for example. All these terms will be dealt with more formally in the next post. For now, just make sure you get the intuition.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bottomline: RL is just learning by trial and error to pick the right actions depending on the state of the environment.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;how-is-it-different-from-supervised-learning-or-unsupervised-learning&#34;&gt;How is it different from Supervised learning or Unsupervised learning?&lt;/h3&gt;

&lt;p&gt;This is the question I get asked the most about RL. The difference between RL and USL is quite clear. In USL, there is absolutely no form of feedback or supervision whereas in RL we do get some sort of feedback in the form of a reward signal.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;So Reinforcement Learning is not Unsupervised learning.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The more pertinent question is &amp;ndash; how is it different from supervised learning? Is RL just SL with class labels given in a different manner?&lt;/p&gt;

&lt;p&gt;Lets look at another very common example. We want to teach our computer to play Tic-Tac-Toe. Our data is in the form of several games that have been played from start to finish. If we consider this as training data for our SL model, the only labels we could possibly decipher from these games would be the final outcome &amp;ndash; the winner of the game or if it was a draw. If we are able to somehow encode the game and train a classifier on the data, this SL model would be able to predict the outcome of a game (which is not very useful) but not &lt;em&gt;how to play the game&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;If we wanted to train a SL model to learn &lt;em&gt;how to play the game&lt;/em&gt;, we would need training data in the form of &lt;em&gt;the best move to play at every board position&lt;/em&gt;. But alas, we do not have such information and this is the case in most problems (think about riding a cycle or playing chess or a video game).&lt;/p&gt;

&lt;p&gt;So what do we do now? For now, take it for granted that RL can solve the problem with the same data and teach a computer how to play Tic-Tac-Toe. We&amp;rsquo;ll talk about how it does it soon enough.&lt;/p&gt;

&lt;p&gt;But since our aim was just to show that RL and SL are not the same, we are done here. SL requires &amp;ldquo;step-wise&amp;rdquo; (this is not a technical term and hence is in quotes, but you get the idea) labels to learn &lt;em&gt;how to do a task&lt;/em&gt;. It requires &amp;ldquo;strong&amp;rdquo; supervision. RL can do the same thing with some sort of &amp;ldquo;weak&amp;rdquo;/&amp;ldquo;distant&amp;rdquo;/&amp;ldquo;semi&amp;rdquo;-supervision.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;So Reinforcement Learning is not Supervised learning either.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;what-problems-can-it-solve&#34;&gt;What problems can it solve?&lt;/h3&gt;

&lt;p&gt;All this sounds great but what problems can RL solve? So far we&amp;rsquo;ve spoken about riding bikes and playing chess and video games but are there any significant real-world problems RL can solve?&lt;/p&gt;

&lt;p&gt;As it turns out there are several. RL is also commonly referred to as &lt;strong&gt;Sequential Decision Making&lt;/strong&gt; or &lt;strong&gt;Decision Making under Uncertainty&lt;/strong&gt;. When we put it this way, we can think of several applications for RL in the real-world. I&amp;rsquo;ll talk about a few here.&lt;/p&gt;

&lt;p&gt;


  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://skandavaidyanath.github.io/img/post1_pong.jpg&#34; data-caption=&#34;Atari Games: Pong. Source: Google Images&#34;&gt;
&lt;img src=&#34;https://skandavaidyanath.github.io/img/post1_pong.jpg&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Atari Games: Pong. Source: Google Images
  &lt;/figcaption&gt;


&lt;/figure&gt;




  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://skandavaidyanath.github.io/img/post1_alphazero.jpg&#34; data-caption=&#34;AlphaZero: Chess. Source: Google Images&#34;&gt;
&lt;img src=&#34;https://skandavaidyanath.github.io/img/post1_alphazero.jpg&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    AlphaZero: Chess. Source: Google Images
  &lt;/figcaption&gt;


&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;RL gained massive popularity because of its success at playing Go and Chess and &lt;a href=&#34;https://arxiv.org/abs/1312.5602&#34; target=&#34;_blank&#34;&gt;Atari Games&lt;/a&gt; as well but there are several other applications of RL.&lt;/p&gt;

&lt;p&gt;RL is extremely versatile and can be used along with several other common ML areas like Computer Vision (CV) and Natural Language Processing (NLP).&lt;/p&gt;

&lt;p&gt;The best example of using RL with CV is probably self-driving cars. With NLP, it can be used in dialogue systems (I recommend you Google how both of this is done to get a better idea). Another massive application area is in robotics and control. It can be used to train multi-agent systems, for example, a swarm of drones communicating with each other. One of my favourite applications of RL is personalized learning where an RL agent can design an optimal course for a student with the right number of tests/assignments administered at the right time to encourage maximum learning. There is similar work being done on personalized healthcare as well.&lt;/p&gt;




  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://skandavaidyanath.github.io/img/post1_robotics.jpg&#34; data-caption=&#34;Robotics. Source: Google Images&#34;&gt;
&lt;img src=&#34;https://skandavaidyanath.github.io/img/post1_robotics.jpg&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Robotics. Source: Google Images
  &lt;/figcaption&gt;


&lt;/figure&gt;


&lt;p&gt;And so there are a ton of different applications you can make using RL. There are also other slightly different uses, for example, RL can be used to &lt;a href=&#34;post/bridging-the-gaps-with-RL/index.md&#34; target=&#34;_blank&#34;&gt;overcome non-differentiable steps in deep learning&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;And with that, we&amp;rsquo;ve answered all the questions that we set out to! We get into a lot more details in the &lt;a href=&#34;https://skandavaidyanath.github.io/courses/rl-course/post2/&#34; target=&#34;_blank&#34;&gt;next post&lt;/a&gt; so make sure you take a look at that as well.&lt;/p&gt;

&lt;p&gt;Feel free to let me know if you have any feedback!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>RL Fundamentals</title>
      <link>https://skandavaidyanath.github.io/courses/rl-course/post2/</link>
      <pubDate>Sun, 05 May 2019 00:00:00 +0100</pubDate>
      <guid>https://skandavaidyanath.github.io/courses/rl-course/post2/</guid>
      <description>

&lt;p&gt;In this post, we&amp;rsquo;ll try to get into the real nitty-gritties of RL and build on the intuition that we gained from the &lt;a href=&#34;https://skandavaidyanath.github.io/courses/rl-course/post1/&#34; target=&#34;_blank&#34;&gt;last article&lt;/a&gt;. So we&amp;rsquo;ll bring in some mathematical foundation and then introduce some RL parlance that we will use for the rest of this course. I strongly recommend that you keep referring back to this post in case you need a refresher on RL terms and symbols. I&amp;rsquo;ll stick to the standard notation from the RL book.&lt;/p&gt;

&lt;p&gt;Before we begin with the mathematical foundations of RL, I&amp;rsquo;d like to point out some issues with RL and what kinds of problems we need to account for if we were to come up with RL algorithms of our own. Once again, I&amp;rsquo;m going to move on to a new example so lets take Chess this time.
So we want to teach our agent (recall what this means from the previous post) how to play the game of chess. Lets assume we have some sort of reward function in place where we get some small positive rewards for capturing a piece and small negative rewards for losing a piece depending on the importance of the piece (so losing a queen would lead to a negative reward of larger magnitude than losing a pawn). We also have some large positive final reward for winning the game and a large positive negative reward for losing. If you&amp;rsquo;re wondering whether just ths large final reward is a sufficient reward function on its own, you&amp;rsquo;re probably right and it probably is, but lets stick to this for the sake of illustration.
Now assume we have an RL algorithm that can look at several games of Chess and the rewards and learn to play Chess on its own. What would this algorithm need to account for? We spoke about trial and error being the basis of any RL algorithm in the previous post that is exactly what our algorithm would do as well. It starts playing random moves and when it plays a good move (positive reward), it remembers to play that move the next time it is in a similar situation. This seems fine on the face of it, but there is an issue. Maybe the algorithm found a good move to play at a given position, &lt;em&gt;but what if there was a better move?&lt;/em&gt;
We need some way for the algorithm to account for the possibility of there being a better move than the one it has found already. So when we train our agent we need to make sure the agent doesn&amp;rsquo;t greedily play the best move it knows all the time but also plays some different moves, hoping that they may be better than the one it already found. This is called the &lt;em&gt;exploration-exploitation tradeoff&lt;/em&gt; in RL. Usually, RL algorithms tend to explore i.e. play many random moves initially and when the agent is more sure about the best moves under different circumstances, it starts exploiting that knowledge.&lt;/p&gt;

&lt;p&gt;Lets move on to the next issue that our RL algorithm will have to account for. Lets say our RL algorithm is learning from a game of Chess again where the player sacrifices the queen but goes on to win the game. The RL agent immediately registers a negative reward for the loss of the queen but the large positive reward for winning the game only comes much later. But it is entirely possible that the very queen sacrifice that the RL agent probably classified as a bad move, was the reason for the player winning the game. How do we account for this in our algorithm? This is the concept of &lt;em&gt;delayed rewards&lt;/em&gt; and we will deal with a simple yet elegant solution for this as well as we go through this post.&lt;/p&gt;

&lt;p&gt;With that background, lets talk about how RL problems are modeled and get into some math.&lt;/p&gt;

&lt;h2 id=&#34;markov-decision-processes&#34;&gt;Markov Decision Processes&lt;/h2&gt;

&lt;p&gt;


  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://skandavaidyanath.github.io/img/post2_mdp_example.jpg&#34; data-caption=&#34;A Markov Decision Process. Source: here&#34;&gt;
&lt;img src=&#34;https://skandavaidyanath.github.io/img/post2_mdp_example.jpg&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    A Markov Decision Process. Source: &lt;a href=&#34;https://randomant.net/reinforcement-learning-concepts/&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;
  &lt;/figcaption&gt;


&lt;/figure&gt;




  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://skandavaidyanath.github.io/img/post2_rl_with_not.jpg&#34; data-caption=&#34;The RL Framework (with some additional details). Source: Google Images&#34;&gt;
&lt;img src=&#34;https://skandavaidyanath.github.io/img/post2_rl_with_not.jpg&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    The RL Framework (with some additional details). Source: Google Images
  &lt;/figcaption&gt;


&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;Almost all RL problems can be modeled as a Markov Decision Process (MDP). So what is an MDP? An MDP can be defined as a five tuple $$\langle \mathcal{S}, \mathcal{A}, \mathcal{P}, \mathcal{R}, \gamma \rangle$$
Lets take a closer look at what all of this means.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; : This is the set of states of the MDP. In an RL setting, this would correspond to different settings of the environment. In the previous post, we spoke about how RL was all about choosing the right actions at the right times i.e. depending on the state of the environment. This is the state we were talking about. A state in chess or tic-tac-toe cpuld be the board positions or while riding a bike could be some combination of the pertinent variables like the angle of the bike with thr ground, the wind speed, etc. The S variable represents the set of all unique states in the MDP.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;A&lt;/em&gt; : This is the set of all actions of the MDP. We already spoke about actions briefly. Actions describe the possible moves in a game of Chess or tic-tac-toe or different arrow keys or buttons in a video game, etc. It represents the different options the agent has and can play at a given point in time. A represents the set of all unique actions available to the agent.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Before we move on to the other symbols, lets get some things clear. Here is another more compilacted MDP for your reference.&lt;/p&gt;




  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://skandavaidyanath.github.io/img/post2_mdp.png&#34; data-caption=&#34;Another MDP. Source: Google Images&#34;&gt;
&lt;img src=&#34;https://skandavaidyanath.github.io/img/post2_mdp.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Another MDP. Source: Google Images
  &lt;/figcaption&gt;


&lt;/figure&gt;


&lt;p&gt;Some of the states of the MDP are designated as start states or initial states and end states or terminal states. An &lt;em&gt;episode&lt;/em&gt; in RL is a sequence of state-action pairs that take the agent from a start state to a terminal state. So the agent starts from one of the intial states, plays an action, goes to the next state and so on until it hits a terminal state and the episode ends.
Now lets take a look at this MDP in the diagram above. Assume &lt;em&gt;S&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt; is your initial state. Notice that &lt;em&gt;a&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt; from &lt;em&gt;S&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt; has two arrows, one going into &lt;em&gt;S&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt; again and another going into &lt;em&gt;S&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt;. The numbers on the arrows indicate 0.5 and 0.5 respectively. This means that if an agent plays the action &lt;em&gt;a&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt; from &lt;em&gt;S&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;, it has a 0.5 probability that it ends up back in &lt;em&gt;S&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt; and a 0.5 probability that it ends up in &lt;em&gt;S&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt;. And similarly we have arrows going all over the diagram. Also notice the wiggly arrows &amp;ndash; they&amp;rsquo;re rewards.
Notationally, we index the sequence of state-action pairs in an episode with a time variable &lt;em&gt;t&lt;/em&gt; so we say an agent plays action &lt;em&gt;a&lt;/em&gt;&lt;sub&gt;t&lt;/sub&gt; from state &lt;em&gt;s&lt;/em&gt;&lt;sub&gt;t&lt;/sub&gt; abnd gets reward &lt;em&gt;r&lt;/em&gt;&lt;sub&gt;t+1&lt;/sub&gt; for doing so (the reward can be 0). Here, &lt;em&gt;t&lt;/em&gt; starts from 0 and we represent the terminal time-step as &lt;em&gt;T&lt;/em&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;P&lt;/em&gt; : Now P is the probability function defined as &lt;em&gt;P&lt;/em&gt;(s&lt;sup&gt;&amp;lsquo;&lt;/sup&gt;| s, a) which is read as the probability of moving to &amp;ldquo;state s&amp;rsquo;&amp;rdquo; from &amp;ldquo;state s&amp;rdquo; if the agent plays &amp;ldquo;action a&amp;rdquo;. So for example, &lt;em&gt;P&lt;/em&gt;(&lt;em&gt;S&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt;|&lt;em&gt;S&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;,&lt;em&gt;a&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;) = 0.5&lt;/li&gt;
&lt;li&gt;&lt;em&gt;R&lt;/em&gt; : This is the reward function and is defined as &lt;em&gt;R&lt;/em&gt;(s&lt;sup&gt;&amp;lsquo;&lt;/sup&gt;| s, a) which is the reward the agent gets for moving to &amp;ldquo;state s&amp;rsquo;&amp;rdquo; from &amp;ldquo;state s&amp;rdquo; if the agent plays &amp;ldquo;action a&amp;rdquo;. So for example, &lt;em&gt;R&lt;/em&gt;(&lt;em&gt;S&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;|&lt;em&gt;S&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;,&lt;em&gt;a&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;) = +5&lt;/li&gt;
&lt;li&gt;$\gamma$ : We spoke about the concept of delayed rewards earlier in the post and we wanted a way to accound for delayed effects of actions. This is where $\gamma$ helps. We define the &lt;em&gt;returns&lt;/em&gt; of an action from a given state as the sum of the &lt;em&gt;discounted rewards&lt;/em&gt; we receive from that state for playing that action. If we started from the state &lt;em&gt;s&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;, the returns would be defined as &lt;em&gt;r&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt; + $\gamma$ &lt;em&gt;r&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt; + $\gamma$&lt;sup&gt;2&lt;/sup&gt; &lt;em&gt;r&lt;/em&gt;&lt;/sub&gt;3&lt;/sub&gt; + &amp;hellip; $\gamma$ &lt;sup&gt;&lt;em&gt;T-1&lt;/em&gt;&lt;/sup&gt; &lt;em&gt;r&lt;/em&gt;&lt;sub&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sub&gt;. We use the word &amp;ldquo;discounted&amp;rdquo; because $\gamma$ is usually a number between 0 and 1 and with the increasing powers, we give more weight to the immediate rewards than the delayed rewards. Hence, $\gamma$ is also called the discounting factor. The symbol we use for returns from timestep &lt;em&gt;t&lt;/em&gt; is usually &lt;em&gt;G&lt;/em&gt;&lt;sub&gt;&lt;em&gt;t&lt;/em&gt;&lt;/sub&gt; although some people like using &lt;em&gt;R&lt;/em&gt; as well (&lt;em&gt;r&lt;/em&gt; for reward and &lt;em&gt;R&lt;/em&gt; for returns). We will stick to the former notation. Now going back to the queen sacrifice example, if we were to consider the returns in our algorithm instead of just the immediate reward, we will be able to account for the delayed positive effect and not just the immediate negative effect.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And with that, we&amp;rsquo;ve covered MDPs and how to model RL problems. But with that definition, we still haven&amp;rsquo;t accounted for the exploration-exploitation tradeoff. So in the &lt;a href=&#34;https://skandavaidyanath.github.io/courses/rl-course/post2/&#34; target=&#34;_blank&#34;&gt;next post&lt;/a&gt;, we&amp;rsquo;ll introduce a few more symbols and definitions and get cracking with our very first RL algorithm!&lt;/p&gt;

&lt;p&gt;Once again, let me know if you have any feedback or suggestions.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://lilianweng.github.io/lil-log/2018/02/19/a-long-peek-into-reinforcement-learning.html&#34; target=&#34;_blank&#34;&gt;A (Long) Peek into Reinforcement Learning by Lilian Weng&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>The Bellman Equation and Dynamic Programming</title>
      <link>https://skandavaidyanath.github.io/courses/rl-course/post3/</link>
      <pubDate>Sun, 05 May 2019 00:00:00 +0100</pubDate>
      <guid>https://skandavaidyanath.github.io/courses/rl-course/post3/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
